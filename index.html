<!--
========================================
PROJECT: Pangolin PvE Simulator (HTML)
========================================
Doel: Single-file simulator met UI, combinatoriek en Monte-Carlo resultaten.

Hoofdstukoverzicht (navigatie voor mensen/AI):
1. CSS Styling
2. Data: Ant definitions & Mechanics Registry
3. Utilities: RNG, combinaties & helpers
4. Select UI logica (teamselectie & filters)
   4.1 populateAnts()
   4.2 enforceFamilyUniq()
   4.3 enforceGroundhogTypes()   <-- added in August 2025
5. Simulatie-engine
   5.1 runSimulation()
   5.2 simulateCombo()
   5.3 pangolinFactor() / andere kernfuncties
6. Find Best Ant Combo
   6.1 Genereren & filteren combinaties (family-unique, groundhog rules)
   6.2 Ranking & Tierlist (Option B: positiepercentielen)
7. Event handlers (modeSelect, antSelects, etc.)
8. Documentatieblokken
   8.1 Groundhog Type Constraints
   8.2 Tierlist uitleg

Opmerking: zoek op de sectiekoppen hieronder (=== SECTION: ...) om direct naar het juiste deel te springen.
-->
<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>The Good's PVE simulator</title>
<meta content="width=device-width, initial-scale=1" name="viewport"/>

<!-- === SECTION: 1. CSS Styling ================================== -->
<style>

/* --- Groundhog soldier tier UI (layout only) --- */
.gh-tiers{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px;margin-top:8px}
.gh-tiers label{display:block}

  :root {
    --bg: #081a36; --text:#e6f2ff; --muted:#9bb3d1; --accent:#00e5ff; --accent2:#7df9ff;
    --card:#0d254a; --border:#13315c;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;color:var(--text);
       background: radial-gradient(1200px 600px at 70% -10%, rgba(0,229,255,0.1), transparent 60%),
                   linear-gradient(180deg,#071f3d,#071a33 30%,#081a36);}
  header{position:relative;height:180px;border-bottom:1px solid var(--border);
          }
  header .brand{position:absolute;left:20px;top:20px;display:flex;gap:12px;align-items:center}
  header img{width:64px;height:64px;border-radius:14px}
  header h1{margin:0;font-size:24px;text-shadow:0 0 10px rgba(0,229,255,.5)}
  main{max-width:1200px;margin:-24px auto 40px;padding:0 16px;display:grid;grid-template-columns:1.2fr 1fr;gap:20px}
  .card{background:rgba(255,255,255,.04);border:1px solid var(--border);border-radius:14px;padding:14px}
  h2{color:var(--accent2);margin:6px 0 10px}
  label{display:block;color:var(--muted);margin-top:8px}
  select,input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:#0a2244;color:var(--text)}
  .grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  button{padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0c2a54;color:var(--text);font-weight:700;cursor:pointer}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border:1px solid var(--border);padding:6px 8px;text-align:right;background:#0b2142}
  th:first-child,td:first-child{text-align:left}
  th{background:#0d2a54;color:var(--accent2)}
  .muted{color:var(--muted);font-size:12px}

  /* Hover glow for The Good's brand */
  .good-brand { cursor: default; }
  .good-brand img { transition: box-shadow .2s ease, filter .2s ease; }
  .good-brand span { transition: text-shadow .2s ease; }
  .good-brand:hover img {
    box-shadow: 0 0 0 2px var(--accent2), 0 0 12px rgba(125,249,255,0.4);
    filter: drop-shadow(0 0 8px rgba(0,229,255,0.5));
    border-radius: 8px;
  }
  .good-brand:hover span {
    text-shadow: 0 0 8px var(--accent2), 0 0 16px rgba(0,229,255,0.8);
  }
</style>

<!-- Injected Tierlist Badges CSS -->
<style>
.badge{padding:2px 6px;border-radius:6px;font-weight:600;display:inline-block}
.badge.S{background:#f1c40f}
.badge.A{background:#2ecc71}
.badge.B{background:#3498db}
.badge.C{background:#9b59b6}
.badge.D{background:#95a5a6}
</style>


<!--
==============================
SECTION: 8. Documentatieblokken
SECTION: Groundhog Type Constraints (DOCUMENTATION)
==============================
In battle type "groundhog", team composition must respect these type rules:
- Shooters (SSA/RC/EJA) may be combined only with Shooters and Universal.
- Carriers (HP?) may be combined only with Carriers and Universal.
- Guardians (LD/HP7) may be combined only with Guardians and Universal.
- Universal (GA) may be combined with any type.
Consequently, within a team of up to 3 ants, any two non-universal types must be equal.
This constraint is enforced in two places:
1) "Select your team" UI: invalid options are disabled dynamically.
2) "Find Best Ant Combo": generation prunes invalid combos early.
-->

<style>

/* === Tier badge palette v2 (S+..F) === */
.badge { border-radius:6px; padding:2px 0; font-weight:600; display:inline-flex; align-items:center; justify-content:center; width:3.5ch; box-sizing:border-box }
.badge.Splus{ background:#e53935; border:2px solid #f1c40f; color:#fff } /* S+ red with gold border */
.badge.S{ background:#e53935; color:#fff }        /* S red */
.badge.A{ background:#f1c40f; color:#000 }        /* A gold */
.badge.B{ background:#2ecc71; color:#fff }        /* B green */
.badge.C{ background:#3498db; color:#fff }        /* C blue */
.badge.D{ background:#9b59b6; color:#fff }        /* D purple */
.badge.E{ background:#e91e63; color:#fff }        /* E pink */
.badge.F{ background:#8d6e63; color:#fff }        /* F brown */

</style>
</head>
<body>
<!-- 
Pangolin PVE Simulator — Uitleg (inline docs)
---------------------------------------------
DATA
- De data staat in <script id="ants-data"> als JSON (DB.ants). Elke ant heeft: id, name, family, sab, tab, awakening, pve { rounds, mechanic, params }.
- Alleen ants met enabled=true komen in de selecties (ANTS = DB.ants.filter(a=>a.enabled)).

SIMULATIE
- Er is per 'family' een mechanic-functie (bijv. simSSA, simGA, simEJA, simRC, sim_hp7_v1) die per ronde kansrollen doet en ruwe schade optelt.
- De simulator draait N samples per rij (Front/Middle/Back) en schaalt de ruwe uitkomsten met:
    pangolinFactor(N, basicAtk, atk%, skill%) * (1 + (pango% + GA-awaken%)/100)
- Resultaten per rij worden samengevat als Average en percentielen (P50/P90) op de geschaalde sample-verdeling.
- 'Total Combined' is per sample de som van de drie rijen; daarop worden Average/P50/P90 opnieuw berekend.

AWAKENINGS & FAMILY-REGEL
- Awakening keys (vooral GA/EJA) beïnvloeden zowel de mechanische damage (indien van toepassing) als Pango-bonus (alleen GA).
- Family uniqueness: in één team mag elke familie maar één keer voorkomen over de drie kolommen (Front/Middle/Back).
- Binnen dezelfde kolom mag je wel varianten van dezelfde familie selecteren (bijv. RC0↔RC4).

BEST COMBINATION
- findBestCombo() doorloopt alle trio's (SSA+GA+EJA) en alle awakening-combinaties, berekent de totaal-avg en sorteert.
- De UI toont de topresultaten in een scrollbaar vlak (om lange lijsten te vermijden).

ONDERHOUD
- Voor nieuwe ants: voeg in <script id="ants-data"> een object toe met pve.mechanic + params en (optioneel) awakening.
- Zorg dat REGISTRY[mechanic] naar de juiste sim-functie wijst.
-->

<header>
<div class="brand">
<h1 class="good-brand" style="display:flex;align-items:center;gap:.6rem"><img alt="The Good avatar" src="img/TheGoodlogo.png" style="height:64px;border-radius:8px"/><span>The Good's Pangolin PVE Simulator</span></h1>
</div>
</header>
<main>
<section class="card">
<h2>Inputs</h2>
<div class="grid2">
<label>Number of Ants (N)<input id="numAnts" type="number" value="100000"/></label>
<label>Base Attack<input id="basicAtk" type="number" value="100"/></label>
<label>Attack Bonus % (base)<input id="atkBonus" type="number" value="1500"/></label>
<label>Skill Attack Bonus %<input id="skillAtkBonus" type="number" value="0"/></label>
<label>Pango or Groundhog Reform %<input id="pangoReform" step="0.1" type="number" value="0"/></label>
<label>Samples<input id="samples" min="1000" step="1000" type="number" value="2000"/></label>
</div>
<p class="muted">Per-row Pangolin: ( √N × BasicAtk × (1+Atk%/100) × (1+SkillAtk%/100) − 1 ) × (skill_damage/100) × (1 + Pango/100 + GA_Awakening/100)</p>
<label style="margin-top:4px">Battle type <select id="modeSelect"><option value="groundhog">groundhog</option><option value="guardians">guardians day</option><option value="shooters">shooters day</option><option value="carriers">carriers day</option></select></label>

<!-- Groundhog tiers (UI only; no logic yet) -->
<div id="groundhogTiers" class="gh-tiers">
  <label>Guardians Tier
    <select id="ghTier_guardians">
      <option value="84" selected>T10 enhanced (84)</option>
      <option value="77">T9 enhanced (77)</option>
    </select>
  </label>
  <label>Shooters Tier
    <select id="ghTier_shooters">
      <option value="136" selected>T10 enhanced (136)</option>
      <option value="115">T9 enhanced (115)</option>
    </select>
  </label>
  <label>Carriers Tier
    <select id="ghTier_carriers">
      <option value="103" selected>T10 enhanced (103)</option>
      <option value="96">T9 enhanced (96)</option>
    </select>
  </label>
</div>

<h2>Select your team </h2>
<div class="grid3">
<div>
<label>Front — Ant<select id="antA"></select></label>
<label>Awakening<select id="awakA"></select></label>
</div>
<div>
<label>Middle — Ant<select id="antB"></select></label>
<label>Awakening<select id="awakB"></select></label>
</div>
<div>
<label>Back — Ant<select id="antC"></select></label>
<label>Awakening<select id="awakC"></select></label>
</div>
</div>
<div style="margin-top:8px;display:flex;gap:10px;flex-wrap:wrap">
<button id="runBtn">Run Simulation</button>
<button id="bestBtn">Find Best Ant Combo</button>
<span class="muted"></span>
</div>
</section>
<section class="card">
<h2>Best Ant Combination</h2>
<div id="comboResults"></div>
</section>
<section class="card" style="grid-column:1/3">
<h2>Results per Row</h2>
<div id="results"></div>
<h2>Total Combined</h2>
<table id="tblTotalBrief"></table>
</section>
</main>
<script id="ants-data" type="application/json">{"meta":{"version":1},"ants":[{"id":"RC0","name":"RC 0\u2605","family":"RC","enabled":true,"pve":{"rounds":8,"mechanic":"rc_v1","params":{"s1":{"p":0.7,"hits":3,"dmg":130.0},"s2":{"activeRounds":4,"dmg":590.0,"chain":[1.0,0.75,0.5,0.25]}}},"sab":101,"tab":85,"awakening":{"type":"none","options":["None"]}},{"id":"RC4","name":"RC 4\u2605","family":"RC","enabled":true,"pve":{"rounds":8,"mechanic":"rc_v1","params":{"s1":{"p":0.7,"hits":3,"dmg":180.0},"s2":{"activeRounds":4,"dmg":590.0,"chain":[1.0,0.75,0.5,0.25]}}},"sab":184,"tab":85,"awakening":{"type":"none","options":["None"]}},{"id":"RC7","name":"RC 7\u2605","family":"RC","enabled":true,"pve":{"rounds":8,"mechanic":"rc_v1","params":{"s1":{"p":0.7,"hits":3,"dmg":180.0},"s2":{"activeRounds":4,"dmg":640.0,"chain":[1.0,0.8,0.6,0.4,0.2]}}},"sab":202,"tab":135,"awakening":{"type":"none","options":["None"]}},{"id":"SSA0","name":"SSA 0\u2605","family":"SSA","enabled":true,"pve":{"rounds":8,"mechanic":"ssa_v1","params":{"s1":{"p":0.8,"targets":3,"bases":[235.0,242.5,262.5],"increment":5.0},"s2":{"p":0.7,"hit":246.66,"hits":3},"s3":{"p":0.5,"flat_per_hit":7.5}}},"sab":78,"tab":60,"awakening":{"type":"none","options":["None"]}},{"id":"GA8","name":"GA 8\u2605","family":"GA","enabled":true,"pve":{"rounds":8,"mechanic":"ga_v1","params":{"base":{"p1":0.55,"p2":0.4,"p3":0.4,"s1":457.5,"s2":642.0,"s3":1086.0,"s3Rounds":4,"mult":1.0},"awak":{"p1":0.65,"p2":0.4,"p3":0.5,"mult":1.0886}}},"sab":75,"tab":50,"awakening":{"type":"ga","options":["None","Green","Blue","Purple","Orange"],"pangobonus":{"None":0.0,"Green":7.5,"Blue":10.0,"Purple":12.5,"Orange":15.0},"sabBonus":{"Green":18,"Blue":18,"Purple":18,"Orange":18}}},{"id":"EJA7","name":"EJA 7\u2605","family":"EJA","enabled":true,"pve":{"rounds":8,"mechanic":"eja_v1","params":{"base":{"p1":0.7,"p2":0.75,"p3":0.8,"s2":490.6,"s3":561.3,"mult_no":1.5},"awak":{"s2":510.96,"mult":1.7,"s3extra_p":0.6,"s3extra":{"None":0.0,"Green":60.0,"Blue":85.2}}}},"sab":156,"tab":100,"awakening":{"type":"eja","options":["None","Green","Blue"],"sabBonus":{"Green":18,"Blue":18}}},{"id":"SSA4","name":"SSA 4\u2605","family":"SSA","enabled":true,"pve":{"rounds":8,"mechanic":"ssa_v1","params":{"s1":{"p":0.8,"targets":3,"bases":[285.0,292.5,312.5],"increment":27.0},"s2":{"p":0.7,"hit":246.66,"hits":3},"s3":{"p":0.5,"flat_per_hit":7.5}}},"sab":138,"tab":60,"awakening":{"type":"none","options":["None"]}},{"id":"HP7","family":"HP","name":"HP 7\u2605","enabled":true,"awakening":{"type":"none","options":["None"]},"sab":111,"tab":80,"pve":{"rounds":8,"mechanic":"hp7_v1","params":{"s1":{"p":0.6,"dmg":450},"s2":{"activeRounds":4,"p":0.6,"targets":3,"dmg":420},"s3":{"p":1.0,"dmg":380}}}},{"id":"LD7","name":"LD 7\u2605","family":"LD","enabled":true,"sab":116,"tab":73,"awakening":{"type":"select","options":["None","Purple"],"sabBonus":{"Purple":18}},"pve":{"rounds":20,"mechanic":"ld_v1","params":{"s1":{"active_rounds":4,"chance":0.8,"hits":3,"dmg":325},"s3":{"active_rounds":8,"chance":1.0,"targets":2,"dmg":200},"s2_bonus_mult":1.159}}},{"id":"GT8","name":"GT8 8\u2605","family":"GT8","enabled":true,"sab":75,"tab":0,"awakening":{"type":"none","options":["None","Blue"],"sabBonus":{"Blue":18}},"pve":{"rounds":8,"mechanic":"ga_v1","params":{"base":{"p1":0.4,"p2":0.35,"p3":0.4,"s1":455.0,"s2":540.0,"s3":644.0,"s3Rounds":8,"mult":1.0},"awak":{"blue":{"rounds":8,"p":0.5,"dmg":125.0,"targets":1}}}}},{"id":"RM8","name":"RM8 8\u2605","family":"RM","enabled":true,"sab":106,"tab":50,"awakening":{"type":"rm8","options":["Blue","None"],"sabBonus":{"Blue":18}},"pve":{"rounds":8,"mechanic":"ga_v1","params":{"base":{"p1":0.5,"p2":0.4,"p3":0.5,"s1":558.0,"s2":566.5,"s3":1350.0,"s3Rounds":3,"mult":1.0,"s2Rounds":4},"awak":{"p1":0.5,"p2":0.4,"p3":0.5,"mult":1.0,"blue":{"rounds":2,"p":0.5,"dmg":290.0,"targets":3}}}}}]}</script>
<script>

<!-- === SECTION: 3. Utilities: RNG, combinations & helpers ====== -->
function rngMulberry32(seed) {
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ t >>> 15, 1 | t);
    r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
    return ((r ^ r >>> 14) >>> 0) / 4294967296;
  }
}
/** Percentielberekening op gesorteerde array met lineaire interpolatie. */
function percentileSorted(sorted, p) {
  const n = sorted.length;
  const k = (n-1)*p;
  const f = Math.floor(k), c = Math.ceil(k);
  if (f===c) return sorted[f];
  return sorted[f] + (sorted[c]-sorted[f])*(k-f);
}
function avg(arr){ let s=0; for(let i=0;i<arr.length;i++) s+=arr[i]; return s/arr.length; }
/** Schaalfactor die N, basicAtk, atk% en skill% verwerkt; wordt toegepast op ruwe sim-output. */

<!-- === SECTION: 5.3 Simulatie-engine: pangolinFactor() ========= -->
function pangolinFactor(N,Basic,AtkPct,SkillPct){ return (Math.sqrt(N)*Basic*(1+AtkPct/100)*(1+SkillPct/100)-1)/100; }

const DB = JSON.parse(document.getElementById('ants-data').textContent);
const ANTS = DB.ants.filter(a=>a.enabled).slice().sort((a,b)=> a.name.localeCompare(b.name, 'en', {sensitivity:'base'}));
// Assign ant types by family
const TYPE_MAP = {HP: 'guardians', SSA: 'shooters', RC: 'shooters', GA: 'universal', EJA: 'shooters', LD: 'guardians',  RM: 'shooters' };
ANTS.forEach(a=>{ a.type = TYPE_MAP[a.family] || 'universal'; });
// Mode filter: guardians day / shooters day / carriers day / groundhog
function currentMode(){ const el = document.getElementById('modeSelect'); return el ? el.value : 'groundhog'; }
function isAllowedByMode(ant){
  const mode = currentMode();
  if (mode==='groundhog') return true;
  if (mode==='guardians') return ant.type==='guardians' || ant.type==='universal';
  if (mode==='shooters')  return ant.type==='shooters'  || ant.type==='universal';
  if (mode==='carriers')  return ant.type==='carriers'  || ant.type==='universal';
  return true;
}
function getFilteredAnts(){ return ANTS.filter(a=> isAllowedByMode(a)); }

// RC
/** RC mechanic. */
function simRC(params, rounds, rnd){
  const {s1, s2} = params;
  let total=0;
  let idx = Array.from({length: rounds}, (_,i)=>i);
  for (let i=idx.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
  const active = new Set(idx.slice(0, s2.activeRounds));
  for (let r=0;r<rounds;r++){
    if (rnd()<s1.p){ total += s1.hits * s1.dmg; }
    if (active.has(r)){
      for (let k=0;k<s2.chain.length;k++){
        if (rnd()<s2.chain[k]) total += s2.dmg; else break;
      }
    }
  }
  return total;
}

// SSA
/** SSA mechanic: per ronde kansrollen voor S1/S2/S3; telt ruwe schade op en retourneert som. */
function simSSA(params, rounds, rnd){
  const {s1, s2, s3} = params;
  let total=0, counts=[0,0,0];
  for (let r=0;r<rounds;r++){
    const buff = (rnd()<s3.p) ? s3.flat_per_hit : 0;
    if (rnd()<s1.p){
      const t = Math.floor(rnd()*s1.targets);
      const d1 = s1.bases[t] + 5*counts[t] + buff;
      counts[t]++;
      const d2 = s1.bases[t] + 5*counts[t] + buff;
      counts[t]++;
      total += d1 + d2;
    }
    if (rnd()<s2.p){
      total += s2.hits * (s2.hit + buff);
    }
  }
  return total;
}

// GA
/** GA mechanic. */
function simGA(params, rounds, rnd, awakeningKey){
  const {base, awak} = params;
  const useAw = !!(awakeningKey && awakeningKey!=="None" && awak);

  // Read probabilities and multipliers with safe fallbacks
  const p1 = useAw && typeof awak.p1 === 'number' ? awak.p1 : base.p1;
  const p2 = useAw && typeof awak.p2 === 'number' ? awak.p2 : base.p2;
  const p3 = useAw && typeof awak.p3 === 'number' ? awak.p3 : base.p3;
  const mult = useAw && typeof awak.mult === 'number' ? awak.mult : (typeof base.mult === 'number' ? base.mult : 1.0);

  // Skill damages
  const s1d = base.s1;
  const s2d = base.s2;
  const s3d = base.s3;

  // Eligible rounds for S3 (existing behavior)
  const s3Rounds = typeof base.s3Rounds === 'number' ? Math.min(rounds, Math.max(0, base.s3Rounds)) : rounds;
  const idx = Array.from({length: rounds}, (_,i)=>i);
  for (let i=idx.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); [idx[i],idx[j]]=[idx[j],idx[i]]; }
  const s3Elig = new Set(idx.slice(0, s3Rounds));

  // Optional: eligible rounds for S2 (new)
  const s2Rounds = typeof base.s2Rounds === 'number' ? Math.min(rounds, Math.max(0, base.s2Rounds)) : null;
  let s2Elig = null;
  if (s2Rounds !== null){
    const idx2 = Array.from({length: rounds}, (_,i)=>i);
    for (let i=idx2.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); [idx2[i],idx2[j]]=[idx2[j],idx2[i]]; }
    s2Elig = new Set(idx2.slice(0, s2Rounds));
  }

  // Awakening Blue (optional extra effect): in BlueRounds with prob BlueP add BlueDmg*BlueTargets
  let blue = null;
  if (useAw && awak.blue){
    const blueRounds = Math.min(rounds, Math.max(0, awak.blue.rounds||0));
    const idx3 = Array.from({length: rounds}, (_,i)=>i);
    for (let i=idx3.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); [idx3[i],idx3[j]]=[idx3[j],idx3[i]]; }
    const blueElig = new Set(idx3.slice(0, blueRounds));
    blue = { p: awak.blue.p||0, dmg: awak.blue.dmg||0, targets: awak.blue.targets||1, elig: blueElig };
  }

  let total=0;
  for (let r=0;r<rounds;r++){
    if (p1 && rnd()<p1) total += s1d;
    if (p2 && rnd()<p2){
      if (!s2Elig || s2Elig.has(r)) total += s2d;
    }
    if (p3 && s3Elig.has(r) && rnd()<p3) total += s3d;

    if (blue && blue.elig.has(r) && rnd() < blue.p){
      total += blue.dmg * blue.targets;
    }
  }
  return total * mult;
}

// EJA
/** EJA mechanic. */
function simEJA(params, rounds, rnd, awakeningKey){
  const {base, awak} = params;
  const mult = (awakeningKey && awakeningKey!=="None") ? awak.mult : base.mult_no;
  const s2 = (awakeningKey && awakeningKey!=="None") ? awak.s2 : base.s2;
  const s3 = base.s3;
  const extraP = (awakeningKey && awakeningKey!=="None") ? awak.s3extra_p : 0;
  const extraVal = (awakeningKey && awakeningKey!=="None") ? (awak.s3extra[awakeningKey]||0) : 0;
  let total=0;
  for (let r=0;r<rounds;r++){
    const order = [1,2,3];
    for (let i=2;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [order[i],order[j]]=[order[j],order[i]]; }
    let boost=false;
    for (let sk of order){
      if (sk===1){
        if (rnd()<base.p1) boost=true;
      }else if (sk===2){
        if (rnd()<base.p2){
          let dmg = s2;
          if (boost){ dmg *= mult; boost=false; }
          total += dmg;
        }
      }else{
        if (rnd()<base.p3){
          let extra = (extraP>0 && rnd()<extraP) ? extraVal : 0;
          let dmg = s3 + extra;
          if (boost){ dmg *= mult; boost=false; }
          total += dmg;
        }
      }
    }
  }
  return total;
}

// LD mechanic: S1 (4 rounds) base 80% (Purple: 85%) for 3x325; S3 (8 rounds) 100% for 2x200 (Purple: 3x200).
function simLD(params, rounds, rnd, awKey){
  var s1 = params.s1||{}; var s3 = params.s3||{};
  var s1chance = (awKey==='Purple') ? 0.85 : (s1.chance||0.80);
  var s3targets = (awKey==='Purple') ? 3 : (s3.targets||2);
  var total=0;
  function pickDistinct(n){
    var idx=[]; for (var i=0;i<rounds;i++) idx.push(i);
    for (var k=idx.length-1;k>0;k--){ var j=Math.floor(rnd()*(k+1)); var t=idx[k]; idx[k]=idx[j]; idx[j]=t; }
    if (n>rounds) n=rounds; return idx.slice(0,n);
  }
  var r1 = pickDistinct(s1.active_rounds||0);
  var r3 = pickDistinct(s3.active_rounds||0);
  for (var i=0;i<r1.length;i++){ if (rnd()<s1chance){ total += (s1.hits||3)*(s1.dmg||325); } }
  for (var j=0;j<r3.length;j++){ var p = (s3 && s3.chance!=null) ? s3.chance : 1.0; if (rnd()<p){ total += s3targets*(s3.dmg||200); } }
  return total;
}

<!-- === SECTION: 2. Data: Mechanics Registry (REGISTRY) ========= -->
const REGISTRY = { "rc_v1": simRC, "ssa_v1": simSSA, "ga_v1": simGA, "eja_v1": simEJA, "ld_v1": simLD };

const sels = {
  A: { ant: document.getElementById('antA'), awak: document.getElementById('awakA') },
  B: { ant: document.getElementById('antB'), awak: document.getElementById('awakB') },
  C: { ant: document.getElementById('antC'), awak: document.getElementById('awakC') }
};


<!-- === SECTION: 4. Select UI logica: populateAnts() ============ -->
function populateAnts(){
  const list = getFilteredAnts();
  for (const key of ['A','B','C']){
    const sel = sels[key].ant;
    const prev = sel.value;
    sel.innerHTML=''; sel.add(new Option('Select ant…',''));
    list.forEach(a=> sel.add(new Option(a.name, a.id)));
    // Restore previous value if still allowed by mode and present in list
    if (prev && list.some(a=> a.id===prev)) sel.value = prev; else sel.value='';
    // Reset awakening list, will be repopulated by onAntChange()
    sels[key].awak.innerHTML = '<option value="None">None</option>';
    if (sel.value) onAntChange(key);
  
  enforceGroundhogTypes();
  enforceFamilyUniq();
}
  enforceGroundhogTypes();
  enforceFamilyUniq();
}

<!-- === SECTION: 4.2 enforceFamilyUniq() ========================= -->
function enforceFamilyUniq(){

  // Recompute disabled state from scratch each time (no sticky disables).
  const chosen = Object.values(sels).map(s=>s.ant.value).filter(Boolean);
  const chosenFams = new Set(chosen.map(id=> (ANTS.find(a=>a.id===id)||{}).family));

  // Determine Groundhog lock type (first selected non-universal), if in groundhog mode
  const modeVal = (document.getElementById('modeSelect')?.value || '').toLowerCase();
  let lockType = null;
  if (modeVal === 'groundhog'){
    const selectedTypes = ['A','B','C']
      .map(k => sels[k]?.ant?.value)
      .filter(Boolean)
      .map(id => (ANTS.find(a=>a.id===id)||{}).type)
      .filter(Boolean);
    const nonUni = selectedTypes.filter(t => t !== 'universal');
    if (nonUni.length) lockType = nonUni[0];
  }

  for (const key of ['A','B','C']){
    const sel = sels[key].ant;
    for (let i=0;i<sel.options.length;i++){
      const opt = sel.options[i];
      if (!opt.value){ opt.disabled=false; continue; }

      const antForOpt = ANTS.find(a=>a.id===opt.value);
      if (!antForOpt) { opt.disabled=false; continue; }

      const fam = antForOpt.family;
      const currentFamily = sel.value ? (ANTS.find(a=>a.id===sel.value)||{}).family : null;

      // Family uniqueness: block if that family is used in any select (other than keeping the current one)
      let famBlocked = false;
      if (sel.value !== opt.value){
        famBlocked = chosenFams.has(fam) && fam !== currentFamily;
      }

      // Groundhog type-lock: if a non-universal type is chosen anywhere, only same type or universal are allowed
      let typeBlocked = false;
      if (lockType){
        const t = antForOpt.type;
        typeBlocked = !(t === 'universal' || t === lockType);
      }

      const blocked = famBlocked || typeBlocked;

      // If the current selection is incompatible under the new lock, clear it
      if (sel.value === opt.value){
        if (blocked){
          sel.value = ''; // reset to placeholder
        }
        opt.disabled = false; // keep the displayed current option enabled; it may be cleared above
      } else {
        opt.disabled = blocked;
      }
    }
  }

}
// Enforce Groundhog type-compatibility across selects.
// Rule: any two non-universal types must be the SAME type.
function groundhogTypesCompatible(types){
  const nonUni = types.filter(t => t !== 'universal');
  if (nonUni.length <= 1) return true;
  const first = nonUni[0];
  for (let i=1;i<nonUni.length;i++){ if (nonUni[i] !== first) return false; }
  return true;
}

// Disable options in the selects that would violate Groundhog rules given current partial selection.

<!-- === SECTION: 4.3 enforceGroundhogTypes() ===================== -->
function enforceGroundhogTypes(){
  let mode = (typeof currentMode==='function') ? currentMode() : (document.getElementById('modeSelect')?.value || '').toLowerCase();
  if ((mode+'').toLowerCase() !== 'groundhog') return;

  // Collect selected types in the three slots
  const selectedTypes = ['A','B','C'].map(k => {
    const id = sels[k].ant.value;
    if (!id) return null;
    const ant = ANTS.find(a=>a.id===id);
    return ant ? ant.type : null;
  }).filter(Boolean);

  // Determine allowed target type(s)
  let lockType = null; // when we already have a non-universal type selected
  const nonUni = selectedTypes.filter(t => t !== 'universal');
  if (nonUni.length >= 1){
    // If there are >=2 different non-universal types already selected, UI is inconsistent; we won't force-fix,
    // but we will restrict further choices to the first non-universal to avoid compounding the conflict.
    lockType = nonUni[0];
  }

  for (const key of ['A','B','C']){
    const sel = sels[key].ant;
    for (let i=0;i<sel.options.length;i++){
      const opt = sel.options[i];
      if (!opt.value){ opt.disabled=false; continue; }
      const ant = ANTS.find(a=>a.id===opt.value);
      if (!ant){ opt.disabled=false; continue; }
      const t = ant.type;

      // Always allow keeping current selection
      const isCurrent = sel.value === opt.value;
      if (isCurrent){ opt.disabled=false; continue; }

      // If no lockType: allow any (universal always allowed anyway)
      if (!lockType){ opt.disabled=false; continue; }

      // With a locked type, allowed choices are: universal or the same locked type
      opt.disabled = !(
        t === 'universal' || t === lockType
      );
    }
  }
}

function onAntChange(rowKey){
  enforceFamilyUniq();
  const id = sels[rowKey].ant.value;
  const awakSel = sels[rowKey].awak;
  awakSel.innerHTML='';
  if (!id){ awakSel.add(new Option('None','None')); return; }
  const ant = ANTS.find(a=>a.id===id);
  const aw = ant.awakening || {type:'none', options:['None']};
  aw.options.forEach(o=> awakSel.add(new Option(o, o)));
}


<!-- === SECTION: 7.1 Event: ant selection change (enforces groundhog rules) === -->
for (const k of ['A','B','C']){
  sels[k].ant.addEventListener('change', ()=>{  onAntChange(k); enforceGroundhogTypes(); enforceFamilyUniq(); });
}

/** Draait de simulatie voor de 3 rijen en werkt UI-resultaten bij. */

<!-- === SECTION: 5.1 Simulatie-engine: runSimulation() ========== -->
function runSimulation(){
  const N = parseInt(document.getElementById('samples').value)||20000;
  const selectedAll = ['A','B','C'].map(k=> sels[k].ant.value);
  const selected = selectedAll.filter(Boolean);
  if (selected.length===0){ alert('Select at least 1 ant.'); return; }
  const fams = selected.map(id=> ANTS.find(a=>a.id===id).family);
  if (new Set(fams).size !== fams.length){ alert('Each selected ant must be a different family.'); return; }
  // Groundhog type-compatibility check
  if (typeof currentMode==='function' && currentMode()==='groundhog'){
    const types = selected.map(id => ANTS.find(a=>a.id===id).type);
    if (!groundhogTypesCompatible(types)){
      alert('Groundhog rule: non-universal types cannot be mixed. Shooters+Guardians/Carriers is invalid (unless Universal is involved).');
      return;
    }
  }
  const ants = selected.map(id=> ANTS.find(a=>a.id===id));
    const effectiveBasic = getEffectiveBasicForTeam(ants);
const selectedKeys = ['A','B','C'].filter(k => sels[k].ant.value);
  const awKeys = selectedKeys.map(k => sels[k].awak.value || 'None');

  const baseAtk = parseFloat(document.getElementById('atkBonus').value)||0;
  const skillB = parseFloat(document.getElementById('skillAtkBonus').value)||0;
  const numAnts = parseFloat(document.getElementById('numAnts').value)||0;
  const basicAtk = parseFloat(document.getElementById('basicAtk').value)||0;
  const pango = parseFloat(document.getElementById('pangoReform').value)||0;

  // Type-aware TAB: each ant receives TAB from same-type ants and universals
const effectiveTAB = ants.map((ai,i)=> ants.reduce((s,aj)=> {
  const giver = aj.type, receiver = ai.type;
  const applies = (giver==='universal') || (receiver==='universal') || (giver===receiver);
  return s + (applies ? (aj.tab||0) : 0);
}, 0));
const rowAtkPct = ants.map((a,i)=> baseAtk + effectiveTAB[i] + (a.sab||0) + ((a.awakening && a.awakening.sabBonus && awKeys) ? (a.awakening.sabBonus[awKeys[i]]||0) : 0));

  // GA awakening additive percent for Pangolin (if any GA chosen)
  let gaAddPct = 0;
  for (let i=0;i<ants.length;i++){
    if (ants[i].family==='GA'){
      const pangomap = ants[i].awakening.pangobonus || {"None":0};
      gaAddPct = pangomap[awKeys[i]] || 0;
      break;
    }
  }
  const combinedAddPct = pango + gaAddPct;
  const hasLD = ants.some(a=> a.pve && a.pve.mechanic==='ld_v1');

  const perRow = [];
  const Narr = new Float64Array(N);
  const total = new Float64Array(N).fill(0);
  for (let row=0; row<ants.length; row++){
    const ant = ants[row];
    const awKey = awKeys[row] || 'None';
    const fn = REGISTRY[ant.pve.mechanic];
    for (let i=0;i<N;i++){
      const keyOffset = {A:0,B:1,C:2}[selectedKeys[row]];
      const r = rngMulberry32(1000 + keyOffset*100000 + i);
      Narr[i] = fn(ant.pve.params, ant.pve.rounds, r, awKey);
    }
    let factor = pangolinFactor(numAnts, effectiveBasic, rowAtkPct[row], skillB) * (1 + combinedAddPct/100);
    if (hasLD){ const t = ants[row].type; if (t==='guardians' || t==='universal' || (ants[row].pve && ants[row].pve.mechanic==='ld_v1')){ factor *= 1.159; } }
    for (let i=0;i<N;i++){ Narr[i] *= factor; total[i] += Narr[i]; }
    const sorted = Array.from(Narr).sort((a,b)=>a-b);
    perRow.push({ name: ant.name + (awKey!=='None'?` [${awKey}]`:''),
      avg: avg(sorted).toFixed(0), p50: percentileSorted(sorted,0.5).toFixed(0), p90: percentileSorted(sorted,0.9).toFixed(0)});
  }
  const sortedTotal = Array.from(total).sort((a,b)=>a-b);
  const nameMap = {A:'Front',B:'Middle',C:'Back'};
  const htmlRows = perRow.map((r,i)=> `<tr><td>${( nameMap[selectedKeys[i]] || `Row ${i+1}` )}</td><td>${r.name}</td><td>${r.avg}</td><td>${r.p50}</td><td>${r.p90}</td></tr>`).join('');
  document.getElementById('results').innerHTML =
    `<table><tr><th>Row</th><th>Ant</th><th>Average</th><th>P50</th><th>P90</th></tr>${htmlRows}</table>`;
  document.getElementById('tblTotalBrief').innerHTML =
    `<tr><th>Average</th><th>P50</th><th>P90</th></tr>
     <tr><td>${avg(sortedTotal).toFixed(0)}</td><td>${percentileSorted(sortedTotal,0.5).toFixed(0)}</td><td>${percentileSorted(sortedTotal,0.9).toFixed(0)}</td></tr>`;
}

/** Genereert en rangschikt 3-ant combinaties (incl. awakenings). */

<!-- === SECTION: 6. Find Best Ant Combo ========================== -->
function findBestCombo(){
  // Use current battle mode filter; fall back to groundhog if element missing
  const list = (typeof getFilteredAnts === 'function') ? getFilteredAnts() : ANTS.slice();
  const ids = list.map(a=>a.id);
  const maxK = Math.min(3, ids.length);
  if (maxK === 0){
    document.getElementById('comboResults').innerHTML = '<div class="muted">No available ants for this mode.</div>';
    return;
  }

  const samples = parseInt(document.getElementById('samples').value)||20000;
  const baseAtk = parseFloat(document.getElementById('atkBonus').value)||0;
  const skillB  = parseFloat(document.getElementById('skillAtkBonus').value)||0;
  const numAnts = parseFloat(document.getElementById('numAnts').value)||0;
  const basicAtk= parseFloat(document.getElementById('basicAtk').value)||0;
  const pango   = parseFloat(document.getElementById('pangoReform').value)||0;

  const GA_REF  = ANTS.find(a=>a.id==='GA8');
  const EJA_REF = ANTS.find(a=>a.id==='EJA7');
  const gaAwOpts  = GA_REF ? (GA_REF.awakening.options || ['None']) : ['None'];
  const ejaAwOpts = EJA_REF ? (EJA_REF.awakening.options || ['None']) : ['None'];

  
<!-- === SECTION: 5.2 Simulatie-engine: simulateCombo() ========== -->
function simulateCombo(arr, awKeys){
  const effectiveBasic = getEffectiveBasicForTeam(arr);

    // Type-aware TAB per row (k = arr.length)
    const effTAB = arr.map((ai,i)=> arr.reduce((s,aj)=>{
      const giver = aj.type, receiver = ai.type;
      const applies = (giver==='universal') || (receiver==='universal') || (giver===receiver);
      return s + (applies ? (aj.tab||0) : 0);
    }, 0));
    const rowAtkPct = arr.map((a,i)=> baseAtk + effTAB[i] + (a.sab||0));

    // GA pangolin additive percent (if GA present)
    let gaAddPct = 0;
    for (let i=0;i<arr.length;i++){
      if (arr[i].family==='GA'){
        const pangomap = arr[i].awakening.pangobonus || {"None":0};
        gaAddPct = pangomap[awKeys[i]] || 0;
        break;
      }
    }
    const combinedAddPct = pango + gaAddPct;
    const hasLD = arr.some(a=> a.pve && a.pve.mechanic==='ld_v1');

    const total = new Float64Array(samples).fill(0);
    for (let row=0; row<arr.length; row++){
      const ant = arr[row];
      const fn = REGISTRY[ant.pve.mechanic];
      for (let i=0;i<samples;i++){
        // stable seeds per fixed row index 0..k-1
        const r = rngMulberry32(2000 + row*100000 + i);
        const raw = fn(ant.pve.params, ant.pve.rounds, r, awKeys[row]);
        let scale = pangolinFactor(numAnts, effectiveBasic, rowAtkPct[row], skillB) * (1 + combinedAddPct/100);
        if (hasLD){ const t = arr[row].type; if (t==='guardians' || t==='universal' || (arr[row].pve && arr[row].pve.mechanic==='ld_v1')){ scale *= 1.159; } }
        total[i] += raw * scale;
      }
    }
    let s=0; for (let i=0;i<samples;i++) s+=total[i];
    return s/samples;
  }

  // Generate combos of size k=1..maxK with family uniqueness
  const results = [];
  function pushResults(comboIds){
    const combo = comboIds.map(id=> list.find(a=>a.id===id));
    // family uniqueness: no duplicate families
    const fams = new Set(combo.map(a=>a.family));
    if (fams.size < combo.length) return;
    // groundhog type rule: any two non-universal types must be equal
    if (typeof currentMode==='function' && currentMode()==='groundhog'){
      const types = combo.map(a=>a.type);
      if (!groundhogTypesCompatible(types)) return;
    }

    // Build awakening options per slot
    const perRowAwOpts = combo.map(a=>{
  const aw = (a.awakening && a.awakening.options) ? a.awakening.options : ['None'];
  return (aw && aw.length) ? aw : ['None'];
});

    // Cartesian product over awakenings
    function rec(idx, currAw){
      if (idx === combo.length){
        const avg = simulateCombo(combo, currAw);
        const label = combo.map((a,i)=>{
          const aw = currAw[i];
          if (aw!=='None') return `${a.name} [${aw}]`;
          return a.name;
        }).join(' + ');
        results.push({ set: label, avg });
        return;
      }
      for (const aw of perRowAwOpts[idx]){
        rec(idx+1, currAw.concat([aw || 'None']));
      }
    }
    rec(0, []);
  }

  // Enumerate combinations
  // k=1
  for (let i=0;i<ids.length;i++){ pushResults([ids[i]]); }
  if (maxK>=2){
    for (let i=0;i<ids.length;i++){
      for (let j=i+1;j<ids.length;j++){
        pushResults([ids[i], ids[j]]);
      }
    }
  }
  if (maxK>=3){
    for (let i=0;i<ids.length;i++){
      for (let j=i+1;j<ids.length;j++){
        for (let k=j+1;k<ids.length;k++){
          pushResults([ids[i], ids[j], ids[k]]);
        }
      }
    }
  }

  results.sort((a,b)=> b.avg - a.avg);
  const top = results.slice(0, 100);
  let html = '<div class="combo-scroll" style="max-height:400px;overflow:auto;border:1px solid var(--border);margin-top:8px;padding-right:20px">';
  
html += '<table id="bestCombos"><thead><tr><th>Tier</th><th>Combo</th><th>Total Avg</th></tr></thead><tbody>';

for (let i=0; i<top.length; i++){
  const r = top[i];
  const topAvg = top.length ? (top[0].avg || 0) : 0;
  const ratio = topAvg > 0 ? (r.avg / topAvg) : 0;
  let label, cls;
  if (ratio >= 0.95){ label='S+'; cls='Splus'; }
  else if (ratio >= 0.85){ label='S'; cls='S'; }
  else if (ratio >= 0.75){ label='A'; cls='A'; }
  else if (ratio >= 0.65){ label='B'; cls='B'; }
  else if (ratio >= 0.50){ label='C'; cls='C'; }
  else if (ratio >= 0.35){ label='D'; cls='D'; }
  else if (ratio >= 0.20){ label='E'; cls='E'; }
  else { label='F'; cls='F'; }
  html += `<tr><td><span class="badge ${cls}">${label}</span></td><td>${r.set}</td><td>${r.avg.toFixed(0)}</td></tr>`;
}

html += '</tbody></table></div>';

  document.getElementById('comboResults').innerHTML = html;
}

document.getElementById('runBtn').addEventListener('click', runSimulation);
document.getElementById('bestBtn').addEventListener('click', findBestCombo);

(function init(){
  // Initialize selects via the same code path as mode changes, so option disabling is consistent.
  try { populateAnts(); } catch(e){ /* fallback to legacy init if needed */ }
  try { enforceGroundhogTypes && enforceGroundhogTypes(); } catch(e){}
  try { enforceFamilyUniq && enforceFamilyUniq(); } catch(e){}
  // Keep mode change listener; if it was inside the old init, ensure it's present here too.
  const modeSel = document.getElementById('modeSelect');
  if (modeSel){
    modeSel.addEventListener('change', ()=>{
      populateAnts();
      enforceGroundhogTypes && enforceGroundhogTypes();
    });
  }
})();
</script>
<script>
// HP7 mechanic: per sample, pick 4 distinct active rounds for S2; in those rounds S2 has 60% chance to hit 3 targets for 420 each.
function sim_hp7_v1(params, rounds, rnd) {
  const { s1, s2, s3 } = params;
  // choose active rounds for S2
  const idx = Array.from({length: rounds}, (_,i)=>i);
  for (let i=idx.length-1;i>0;i--){ const j = Math.floor(rnd()*(i+1)); const t = idx[i]; idx[i] = idx[j]; idx[j] = t; }
  const activeS2 = new Set(idx.slice(0, s2.activeRounds || 0));
  let sum = 0;
  for (let r=0; r<rounds; r++){
    if (rnd() < (s1.p || 0)) { sum += (s1.dmg || 0); }
    if (activeS2.has(r) && rnd() < (s2.p || 0)) {
      for (let t=0; t<(s2.targets || 0); t++) sum += (s2.dmg || 0);
    }
    if (rnd() < (s3.p || 0)) { sum += (s3.dmg || 0); }
  }
  return sum;
}


try {
  if (typeof REGISTRY !== 'undefined') {
    REGISTRY['hp7_v1'] = sim_hp7_v1;
  }
} catch(e) { console && console.warn && console.warn('HP7 registry add failed', e); }
</script>
<!-- Injected Tierlist JS (Option B: position percentiles) -->
<script>
(function(){
  function ensureTierHeader(table){
    const thead = table.querySelector('thead');
    if(!thead) return;
    const firstRow = thead.rows[0];
    if(!firstRow) return;
    // If first column already is 'Tier', skip
    if(firstRow.cells.length && /Tier/i.test(firstRow.cells[0].textContent || '')) return;
    const th = document.createElement('th');
    th.textContent = 'Tier';
    firstRow.insertBefore(th, firstRow.firstElementChild || null);
  }

  function tierBadge(t){
    const span = document.createElement('span');
    span.className = 'badge ' + t;
    span.textContent = t;
    return span;
  }

  
function assignTiersByRankRows(table){
  const tbody = table.querySelector('tbody');
  if(!tbody) return;
  const rows = Array.from(tbody.rows);
  if (rows.length === 0) return;
  const parseNum = (txt)=>{
    const v = parseFloat((txt||'').toString().replace(/[^0-9.+-eE]/g,''));
    return isFinite(v)? v : 0;
  };
  const topAvg = parseNum(rows[0].cells[2]?.textContent);
  rows.forEach(tr => {
    const val = parseNum(tr.cells[2]?.textContent);
    const ratio = topAvg > 0 ? (val / topAvg) : 0;
    let label, cls;
    if (ratio >= 0.95){ label='S+'; cls='Splus'; }
    else if (ratio >= 0.85){ label='S'; cls='S'; }
    else if (ratio >= 0.75){ label='A'; cls='A'; }
    else if (ratio >= 0.65){ label='B'; cls='B'; }
    else if (ratio >= 0.50){ label='C'; cls='C'; }
    else if (ratio >= 0.35){ label='D'; cls='D'; }
    else if (ratio >= 0.20){ label='E'; cls='E'; }
    else { label='F'; cls='F'; }
    const cell = tr.cells[0];
    const badge = cell ? cell.querySelector('.badge') : null;
    if (badge){
      badge.className = 'badge ' + cls;
      badge.textContent = label;
    }
  });
}
else{
        const td = document.createElement('td');
        td.appendChild(tierBadge(t));
        tr.insertBefore(td, tr.firstElementChild || null);
      }
    });
  }

  function applyTierList(){
    // Prefer table with id="bestCombos", else fall back to first table within an element with id or class containing 'best' & 'combo'
    let table = document.querySelector('#bestCombos');
    if(!table){
      table = document.querySelector('table#best-combos, table.bestCombos, table.best-combos, [id*="best"][id*="combo"] table, [class*="best"][class*="combo"] table');
    }
    if(!table) return;

    ensureTierHeader(table);
    assignTiersByRankRows(table);

    // Observe for changes and re-apply tiers
    const tbody = table.querySelector('tbody');
    if(!tbody) return;
    if(tbody._tierObserverAttached) return;
    const obs = new MutationObserver(() => {
      // Re-ensure header (in case it's rebuilt) and (re)assign tiers
      ensureTierHeader(table);
      assignTiersByRankRows(table);
    });
    obs.observe(tbody, { childList: true, subtree: false });
    tbody._tierObserverAttached = true;
  }

  // Run after DOM content loaded and also after a small delay to catch async rendering
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      applyTierList();
      setTimeout(applyTierList, 100);
      setTimeout(applyTierList, 300);
      setTimeout(applyTierList, 800);
    });
  }else{
    applyTierList();
    setTimeout(applyTierList, 100);
    setTimeout(applyTierList, 300);
    setTimeout(applyTierList, 800);
  }
})();
</script>


<script>
function getTierBasic(type){
  const map = {guardians:'ghTier_guardians', shooters:'ghTier_shooters', carriers:'ghTier_carriers'};
  const id = map[type] || map['shooters'];
  const el = document.getElementById(id);
  const fallback = (type==='shooters') ? 136 : (type==='carriers' ? 103 : 84);
  if (!el) return fallback;
  const opt = el.options[el.selectedIndex];
  if (!opt) return fallback;
  let v = parseFloat(opt.value);
  if (!isFinite(v)){
    const txt = (opt.textContent||'').trim();
    const m = txt.match(/(\d+(?:\.\d+)?)(?!.*\d)/);
    v = m ? parseFloat(m[1]) : NaN;
  }
  if (!isFinite(v) || v<=0) return fallback;
  return v;
}
function getEffectiveBasicForTeam(ants){
  try{
    const types = (ants||[]).map(a=>a && a.type).filter(Boolean);
    const nonUni = types.filter(t => t !== 'universal');
    const lockType = nonUni.length ? nonUni[0] : 'shooters';
    return getTierBasic(lockType);
  }catch(e){ return 136; }
}
</script>

<!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "b6f6a5547473410899aa22d54af35d9b"}'></script><!-- End Cloudflare Web Analytics -->

</body>
</html>
